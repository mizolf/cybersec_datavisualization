<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Security Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="chart-container">
        <h1>Global Cybersecurity Metrics Map</h1>
        <div id="controls">
            <label for="metric-select">Select Metric for Map:</label>
            <select id="metric-select">
                <option value="gci" selected>Global Cybersecurity Index (GCI)</option>
                <option value="cei">Cybersecurity Exposure Index (CEI)</option>
                <option value="ncsi">National Cyber Security Index (NCSI)</option>
                <option value="ddl">Digital Development Level (DDL)</option>
            </select>
            <button id="reset-zoom-button">Reset View</button>
        </div>
        <div id="map-container">
            <svg id="world-map"></svg>
        </div>
        <div id="tooltip"></div>
        <div class="legend">
            <div id="dynamic-legend-header"></div>
            <div class="legend-item">
                <span class="legend-color-swatch" style="background-color: #e0e0e0;"></span>
                No data / Not in dataset
            </div>
            <div id="dynamic-legend-items"></div>
        </div>
    </div>

    <div class="chart-container">
        <div id="country-metrics-chart-container"> <!-- Renamed ID -->
            <p class="chart-placeholder-text">Kliknite na državu na karti kako biste vidjeli njezine metrike.</p>
            <svg id="country-metrics-chart" style="display: none;"></svg> <!-- Initially hidden -->
        </div>
    </div>


    <script>
        // --- MAP CODE (largely unchanged, just ensure cyberDataStore is accessible) ---
        const mapWidth = document.getElementById('map-container').clientWidth;
        const mapHeight = mapWidth * 0.6;

        const mapSvg = d3.select("#world-map") 
            .attr("viewBox", `0 0 ${mapWidth} ${mapHeight}`)
            .attr("preserveAspectRatio", "xMidYMid meet");

        const mapTooltip = d3.select("#tooltip"); 

        const metricCategories = { 
            cei: { displayName: "Cybersecurity Exposure Index (CEI)", shortName: "CEI", domain: [0.35, 0.67], range_colors: ["#77dd77", "#fdfd96", "#ff6961"], range_labels: ["Secure (0.00 - 0.34)", "Potentially Vulnerable (0.35 - 0.66)", "High Exposure (0.67 - 1.00)"], description: "Lower CEI indicates less cybersecurity exposure." },
            gci: { displayName: "Global Cybersecurity Index (GCI)", shortName: "GCI", domain: [40, 70], range_colors: ["#ff6961", "#fdfd96", "#77dd77"], range_labels: ["Low Commitment (< 40)", "Medium Commitment (40 - 69.99)", "High Commitment (>= 70)"], description: "Higher GCI indicates a stronger commitment to cybersecurity." },
            ncsi: { displayName: "National Cyber Security Index (NCSI)", shortName: "NCSI", domain: [40, 70], range_colors: ["#ff6961", "#fdfd96", "#77dd77"], range_labels: ["Basic Preparedness (< 40)", "Developing Preparedness (40 - 69.99)", "Advanced Preparedness (>= 70)"], description: "Higher NCSI indicates better national cybersecurity preparedness." },
            ddl: { displayName: "Digital Development Level (DDL)", shortName: "DDL", domain: [40, 70], range_colors: ["#ff6961", "#fdfd96", "#77dd77"], range_labels: ["Low Development (< 40)", "Medium Development (40 - 69.99)", "High Development (>= 70)"], description: "Higher DDL indicates a more advanced digital infrastructure." }
        };
        let currentMapMetric = 'gci'; 
        let cyberDataStore = []; 
        let dataByCountryStore = new Map();
        const mapColorScale = d3.scaleThreshold(); 

        const nameMappings = {  
             "United States of America": "United States", "Russian Federation": "Russia", "Dem. Rep. Congo": "Congo", "Congo": "Congo", "Dominican Rep.": "Dominican Republic", "Central African Rep.": "Central African Republic", "Korea": "South Korea", "Dem. People's Rep. Korea": "North Korea", "Czechia": "Czech Republic", "Côte d'Ivoire": "Cote d'ivoire", "Myanmar": "Myanmar", "Lao People's Dem. Rep.": "Lao PDR", "Brunei Darussalam": "Brunei Darussalam", "Syrian Arab Republic": "Syria", "Iran (Islamic Republic of)": "Iran", "Bosnia and Herz.": "Bosnia and Herzegovina", "North Macedonia": "North Macedonia", "Macedonia": "North Macedonia", "S. Sudan": "South Sudan", "Solomon Is.": "Solomon Islands", "Timor-Leste": "Timor-Leste", "United Rep. of Tanzania": "Tanzania", "eSwatini": "Eswatini", "State of Palestine": "Palestine", "Palestine": "Palestine", "Taiwan": "Taiwan", "Serbia": "Serbia", "Viet Nam": "Vietnam", "Vatican": "Vatican City", "Holy See": "Vatican City"
        };
        const mapProjection = d3.geoMercator(); 
        const mapPathGenerator = d3.geoPath().projection(mapProjection); 
        const mapGroup = mapSvg.append("g").attr("id", "map-group");
        const mapZoom = d3.zoom().scaleExtent([1, 8]).on("zoom", (event) => {
            mapGroup.attr("transform", event.transform);
        });
        mapSvg.call(mapZoom);

        function formatMapMetricValue(metricKey, value) {  
            if (value === null || isNaN(value)) return 'N/A';
            if (metricKey === 'cei' && (value < 10 || value === 0)) return value.toFixed(3);
            return value.toFixed(2);
        }
        function getMapCategoryInfo(metricKey, value) { 
            if (value === null || isNaN(value)) return { label: 'N/A', color: '#e0e0e0' };
            const categories = metricCategories[metricKey];
            if (!categories) return { label: 'N/A', color: '#e0e0e0' };
            const thresholds = categories.domain; const labels = categories.range_labels; const colors = categories.range_colors;
            for (let i = 0; i < thresholds.length; i++) { if (value < thresholds[i]) { return { label: labels[i], color: colors[i] }; } }
            return { label: labels[labels.length - 1], color: colors[colors.length - 1] };
        }

        function updateMapAndLegend(metricKey) {
            currentMapMetric = metricKey;
            const currentCategorySet = metricCategories[metricKey];
            mapColorScale.domain(currentCategorySet.domain).range(currentCategorySet.range_colors);
            mapGroup.selectAll("path.country")
                .transition().duration(300)
                .attr("fill", d_geo => {  
                    const geoName = d_geo.properties.name; const csvName = nameMappings[geoName] || geoName;
                    const countryData = dataByCountryStore.get(csvName);
                    if (countryData && countryData[metricKey] !== null && !isNaN(countryData[metricKey])) {
                        return mapColorScale(countryData[metricKey]);
                    } return "#e0e0e0";
                });
            const legendHeader = d3.select("#dynamic-legend-header"); legendHeader.html("");
            legendHeader.append("div").attr("class", "legend-title").text(currentCategorySet.displayName);
            legendHeader.append("div").attr("class", "legend-description").text(currentCategorySet.description);
            const legendItemsContainer = d3.select("#dynamic-legend-items"); legendItemsContainer.html("");
            currentCategorySet.range_colors.forEach((color, i) => {  
                const label = currentCategorySet.range_labels[i];
                const legendItem = legendItemsContainer.append("div").attr("class", "legend-item");
                legendItem.append("span").attr("class", "legend-color-swatch").style("background-color", color);
                legendItem.append("span").text(label);
            });
        }
        // --- END OF MAP CODE (mostly) ---

        // --- COUNTRY METRICS BAR CHART CODE ---
        function drawCountryMetricsChart(countryData) {
            if (!countryData) {
                d3.select("#country-metrics-chart-container .chart-placeholder-text")
                  .style("display", "block")
                  .text("Podaci za odabranu državu nisu dostupni.");
                d3.select("#country-metrics-chart").style("display", "none");
                return;
            }
            
            d3.select("#country-metrics-chart-container .chart-placeholder-text").style("display", "none");
            const chartSvg = d3.select("#country-metrics-chart").style("display", "block");
            chartSvg.selectAll("*").remove(); // Clear previous chart content

            const metricsData = [
                { metric: 'gci', value: countryData.gci, label: metricCategories.gci.shortName, fullName: metricCategories.gci.displayName, color: "#1f77b4" },
                { metric: 'ncsi', value: countryData.ncsi, label: metricCategories.ncsi.shortName, fullName: metricCategories.ncsi.displayName, color: "#ff7f0e" },
                { metric: 'ddl', value: countryData.ddl, label: metricCategories.ddl.shortName, fullName: metricCategories.ddl.displayName, color: "#2ca02c" },
                { metric: 'cei', value: countryData.cei, label: metricCategories.cei.shortName, fullName: metricCategories.cei.displayName, color: "#d62728" }
            ].filter(d => d.value !== null && !isNaN(d.value));

            if (metricsData.length === 0) {
                 d3.select("#country-metrics-chart-container .chart-placeholder-text")
                  .style("display", "block")
                  .text(`Nema dostupnih metričkih podataka za ${countryData.country}.`);
                chartSvg.style("display", "none");
                return;
            }

            const containerNode = d3.select("#country-metrics-chart-container").node();
            const svgWidth = containerNode.getBoundingClientRect().width;
            const svgHeight = 400; // Fixed height for this chart
            const margin = { top: 60, right: 30, bottom: 70, left: 60 }; // Increased bottom margin for labels
            const chartWidth = svgWidth - margin.left - margin.right;
            const chartHeight = svgHeight - margin.top - margin.bottom;

            chartSvg.attr("width", svgWidth).attr("height", svgHeight);
            const chartG = chartSvg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Title
            chartSvg.append("text")
                .attr("x", svgWidth / 2)
                .attr("y", margin.top / 2)
                .attr("text-anchor", "middle")
                .attr("class", "metrics-chart-title")
                .text(`Cybersecurity Metrike za: ${countryData.country}`);

            const xScale = d3.scaleBand()
                .domain(metricsData.map(d => d.label)) // Use short names for x-axis
                .range([0, chartWidth])
                .padding(0.3);

            const maxValue = d3.max(metricsData, d => d.value);
            const yScale = d3.scaleLinear()
                .domain([0, maxValue > 0 ? maxValue * 1.1 : 10]) // Add 10% padding, or default if max is 0 or negative
                .range([chartHeight, 0]);

            // Bars
            chartG.selectAll(".bar")
                .data(metricsData)
                .join("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.label))
                .attr("y", d => yScale(d.value))
                .attr("width", xScale.bandwidth())
                .attr("height", d => chartHeight - yScale(d.value))
                .attr("fill", d => d.color)
                .on("mouseover", function(event, d) { // Simple tooltip for full name
                    mapTooltip.style("opacity", 1)
                        .html(`<strong>${d.fullName}</strong><br>Vrijednost: ${formatMapMetricValue(d.metric, d.value)}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    mapTooltip.style("opacity", 0);
                });
            
            // Value labels on bars
            chartG.selectAll(".bar-value-label")
                .data(metricsData)
                .join("text")
                .attr("class", "bar-value-label")
                .attr("x", d => xScale(d.label) + xScale.bandwidth() / 2)
                .attr("y", d => yScale(d.value) - 5) // Position above the bar
                .text(d => formatMapMetricValue(d.metric, d.value));


            // X-axis
            chartG.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text") // Further style X-axis labels if they overlap
                .style("text-anchor", "middle");


            // Y-axis
            chartG.append("g")
                .attr("class", "y-axis")
                .call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format(".2~f"))); // General format, adapt if needed
            
            // Y-axis Label
            chartSvg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", margin.left / 4)
                .attr("x", 0 - (chartHeight / 2) - margin.top)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .attr("class", "axis-label")
                .text("Vrijednost Indeksa");
        }

        // Function to initialize the placeholder for the country chart
        function initializeCountryChartPlaceholder() {
            const container = d3.select("#country-metrics-chart-container");
            container.select(".chart-placeholder-text").style("display", "block");
            container.select("#country-metrics-chart").style("display", "none");
        }

        // --- END OF COUNTRY METRICS BAR CHART CODE ---


        // --- DATA LOADING AND INITIALIZATION ---
        Promise.all([
            d3.json("https://unpkg.com/world-atlas@2/countries-110m.json"),
            d3.csv("Cyber_security.csv", d_csv => { 
                return {
                    country: d_csv.Country, region: d_csv.Region,
                    cei: d_csv.CEI && d_csv.CEI.trim() !== "" ? +d_csv.CEI : null,
                    gci: d_csv.GCI && d_csv.GCI.trim() !== "" ? +d_csv.GCI : null,
                    ncsi: d_csv.NCSI && d_csv.NCSI.trim() !== "" ? +d_csv.NCSI : null,
                    ddl: d_csv.DDL && d_csv.DDL.trim() !== "" ? +d_csv.DDL : null
                };
            })
        ]).then(([worldData, loadedCyberData]) => {
            cyberDataStore = loadedCyberData; 
            dataByCountryStore = new Map(cyberDataStore.map(d => [d.country, d]));

            const countries = topojson.feature(worldData, worldData.objects.countries);
            mapProjection.fitSize([mapWidth, mapHeight], countries);
            mapGroup.selectAll("path.country")
                .data(countries.features)
                .join("path")
                .attr("class", "country")
                .attr("d", mapPathGenerator)
                .style("vector-effect", "non-scaling-stroke")
                .on("mouseover", function(event, d_geo) {  
                    mapTooltip.style("opacity", 1); d3.select(this).raise();
                })
                .on("mousemove", function(event, d_geo) {  
                    const geoName = d_geo.properties.name; const csvName = nameMappings[geoName] || geoName;
                    const countryData = dataByCountryStore.get(csvName);
                    let tooltipText = `<strong>${geoName}</strong>`;
                    if (countryData) {
                        const metricValue = countryData[currentMapMetric];
                        const categoryInfo = getMapCategoryInfo(currentMapMetric, metricValue);
                        tooltipText += `<br><span class="tooltip-metric">${metricCategories[currentMapMetric].displayName}: ${formatMapMetricValue(currentMapMetric, metricValue)}</span>`;
                        tooltipText += `<br><span class="tooltip-category">Category: ${categoryInfo.label}</span>`;
                        tooltipText += `<br>Region: ${countryData.region || 'N/A'}`;
                        for (const key in metricCategories) {
                            if (key !== currentMapMetric && countryData[key] !== null) {
                                tooltipText += `<br><small>${metricCategories[key].displayName}: ${formatMapMetricValue(key, countryData[key])} (${getMapCategoryInfo(key, countryData[key]).label})</small>`;
                            }
                        }
                    } else { tooltipText += "<br>Data not available in CSV dataset"; }
                    mapTooltip.html(tooltipText).style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 30) + "px");
                })
                .on("mouseout", function(event, d_geo) { mapTooltip.style("opacity", 0); })
                .on("click", function(event, d_geo) { // <<<--- CLICK HANDLER FOR MAP
                    const geoName = d_geo.properties.name;
                    const csvName = nameMappings[geoName] || geoName;
                    const countryDetails = dataByCountryStore.get(csvName);
                    if (countryDetails) {
                        drawCountryMetricsChart(countryDetails);
                    } else {
                        // Handle case where country from map is not in CSV or has no data
                        drawCountryMetricsChart( { country: geoName } ); // Pass at least name to show in title
                        console.warn(`No detailed data for ${geoName} (CSV name: ${csvName})`);
                    }
                });
            
            updateMapAndLegend(currentMapMetric);
            initializeCountryChartPlaceholder(); // Initialize placeholder for the country chart

            // Event Listeners for Map Controls
            d3.select("#metric-select").on("change", function(event) {
                updateMapAndLegend(d3.select(this).property("value"));
            });
            d3.select("#reset-zoom-button").on("click", () => {
                mapSvg.transition().duration(750).call(mapZoom.transform, d3.zoomIdentity);
            });


        }).catch(error => {
            console.error("Error loading data:", error);
            mapSvg.append("text").attr("x", 20).attr("y", 50).text("Error loading map or CSV. Check console.");
            d3.select("#dynamic-legend-header").html(`<p class="legend-title" style="color: red;">Error loading data.</p><p class="legend-description">Check console for details.</p>`);
            d3.select("#country-metrics-chart-container").html(`<p class="chart-placeholder-text" style="color: red;">Error loading data. See console.</p>`);
        });
    </script>
</body>
</html>