<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Security Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="map-container">
        <h1>Global Cybersecurity Metrics Map</h1>
        <div id="controls">
            <label for="metric-select">Select Metric for Map:</label>
            <select id="metric-select">
                <option value="gci" selected>Global Cybersecurity Index (GCI)</option>
                <option value="cei">Cybersecurity Exposure Index (CEI)</option>
                <option value="ncsi">National Cyber Security Index (NCSI)</option>
                <option value="ddl">Digital Development Level (DDL)</option>
            </select>
            <button id="reset-zoom-button">Reset View</button>
        </div>
        <div id="map-container">
            <svg id="world-map"></svg>
        </div>
        <div id="tooltip"></div>
        <div class="legend">
            <div id="dynamic-legend-header"></div>
            <div class="legend-item">
                <span class="legend-color-swatch" style="background-color: #e0e0e0;"></span>
                No data / Not in dataset
            </div>
            <div id="dynamic-legend-items"></div>
        </div>
    </div>

    <div class="chart-gauge-container">
        <div class="chart-container" id="country-specific-dashboard">
            <div id="country-metrics-chart-container"> 
                <p class="chart-placeholder-text">Click on a country on the map to see its metrics.</p>
                <svg id="country-metrics-chart" style="display: none;"></svg> 
            </div>
        </div>
        <div class="chart-container" id="country-gauge-info-container">
            <div id="country-gauge-chart-container">
                <svg id="country-gauge-chart" style="display:none;"></svg>
            </div>
            <div id="country-info-display">
            </div>
        </div>
        <div class="chart-container" id="top-bottom-countries-container">
            <h3>Top 3 Most Secure and Most Exposed Countries</h3>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                <div class="country-list-section" id="safest-countries-list">
                    <h4><span style="color: #28a745;">●</span> Most Secure Countries</h4>
                    <ul></ul>
                </div>
                <div class="country-list-section" id="most-exposed-countries-list">
                    <h4><span style="color: #dc3545;">●</span> Most Exposed Countries</h4>
                    <ul></ul>
                </div>
            </div>
        </div>
    </div>
            
    <script>
        // --- MAP CODE ---
        const mapWidth = document.getElementById('map-container').clientWidth;
        const mapHeight = mapWidth * 0.6;
        const mapSvg = d3.select("#world-map").attr("viewBox", `0 0 ${mapWidth} ${mapHeight}`).attr("preserveAspectRatio", "xMidYMid meet");
        const mapTooltip = d3.select("#tooltip"); 
        const metricCategories = { 
            cei: { displayName: "Cybersecurity Exposure Index (CEI)", shortName: "CEI", domain: [0.35, 0.67], range_colors: ["#77dd77", "#fdfd96", "#ff6961"], range_labels: ["Secure (0.00 - 0.34)", "Potentially Vulnerable (0.35 - 0.66)", "High Exposure (0.67 - 1.00)"], description: "Lower CEI indicates less cybersecurity exposure." },
            gci: { displayName: "Global Cybersecurity Index (GCI)", shortName: "GCI", domain: [40, 70], range_colors: ["#ff6961", "#fdfd96", "#77dd77"], range_labels: ["Low Commitment (< 40)", "Medium Commitment (40 - 69.99)", "High Commitment (>= 70)"], description: "Higher GCI indicates a stronger commitment to cybersecurity." },
            ncsi: { displayName: "National Cyber Security Index (NCSI)", shortName: "NCSI", domain: [40, 70], range_colors: ["#ff6961", "#fdfd96", "#77dd77"], range_labels: ["Basic Preparedness (< 40)", "Developing Preparedness (40 - 69.99)", "Advanced Preparedness (>= 70)"], description: "Higher NCSI indicates better national cybersecurity preparedness." },
            ddl: { displayName: "Digital Development Level (DDL)", shortName: "DDL", domain: [40, 70], range_colors: ["#ff6961", "#fdfd96", "#77dd77"], range_labels: ["Low Development (< 40)", "Medium Development (40 - 69.99)", "High Development (>= 70)"], description: "Higher DDL indicates a more advanced digital infrastructure." }
        };
        let currentMapMetric = 'gci'; 
        let cyberDataStore = []; 
        let dataByCountryStore = new Map();
        const mapColorScale = d3.scaleThreshold(); 
        const nameMappings = { "United States of America": "United States", "Russian Federation": "Russia", "Dem. Rep. Congo": "Congo", "Congo": "Congo", "Dominican Rep.": "Dominican Republic", "Central African Rep.": "Central African Republic", "Korea": "South Korea", "Dem. People's Rep. Korea": "North Korea", "Czechia": "Czech Republic", "Côte d'Ivoire": "Cote d'ivoire", "Myanmar": "Myanmar", "Lao People's Dem. Rep.": "Lao PDR", "Brunei Darussalam": "Brunei Darussalam", "Syrian Arab Republic": "Syria", "Iran (Islamic Republic of)": "Iran", "Bosnia and Herz.": "Bosnia and Herzegovina", "North Macedonia": "North Macedonia", "Macedonia": "North Macedonia", "S. Sudan": "South Sudan", "Solomon Is.": "Solomon Islands", "Timor-Leste": "Timor-Leste", "United Rep. of Tanzania": "Tanzania", "eSwatini": "Eswatini", "State of Palestine": "Palestine", "Palestine": "Palestine", "Taiwan": "Taiwan", "Serbia": "Serbia", "Viet Nam": "Vietnam", "Vatican": "Vatican City", "Holy See": "Vatican City"};
        const mapProjection = d3.geoMercator(); 
        const mapPathGenerator = d3.geoPath().projection(mapProjection); 
        const mapGroup = mapSvg.append("g").attr("id", "map-group");
        const mapZoom = d3.zoom().scaleExtent([1, 8]).on("zoom", (event) => mapGroup.attr("transform", event.transform));
        mapSvg.call(mapZoom);
        function formatMapMetricValue(metricKey, value) { if (value === null || isNaN(value)) return 'N/A'; if (metricKey === 'cei' && (value < 10 || value === 0)) return value.toFixed(3); return value.toFixed(2); }
        function getMapCategoryInfo(metricKey, value) { if (value === null || isNaN(value)) return { label: 'N/A', color: '#e0e0e0' }; const cat = metricCategories[metricKey]; if (!cat) return { label: 'N/A', color: '#e0e0e0' }; const th = cat.domain, L = cat.range_labels, C = cat.range_colors; for (let i=0; i<th.length; i++) if(value<th[i]) return {label:L[i],color:C[i]}; return {label:L[L.length-1],color:C[C.length-1]};}
        function updateMapAndLegend(metricKey) { currentMapMetric = metricKey; const C = metricCategories[metricKey]; mapColorScale.domain(C.domain).range(C.range_colors); mapGroup.selectAll("path.country").transition().duration(300).attr("fill",d_geo=>{const gN=d_geo.properties.name,cN=nameMappings[gN]||gN,cD=dataByCountryStore.get(cN); if(cD&&cD[metricKey]!==null&&!isNaN(cD[metricKey]))return mapColorScale(cD[metricKey]); return "#e0e0e0";}); const lH=d3.select("#dynamic-legend-header");lH.html("");lH.append("div").attr("class","legend-title").text(C.displayName);lH.append("div").attr("class","legend-description").text(C.description); const lI=d3.select("#dynamic-legend-items");lI.html(""); C.range_colors.forEach((c,i)=>{const L=C.range_labels[i],item=lI.append("div").attr("class","legend-item");item.append("span").attr("class","legend-color-swatch").style("background-color",c);item.append("span").text(L);});}
        // --- END OF MAP CODE ---

        // --- COUNTRY METRICS BAR CHART CODE ---
        function drawCountryMetricsChart(countryData) {
            if (!countryData) { d3.select("#country-metrics-chart-container .chart-placeholder-text").style("display", "block").text("Data for the selected country is not available."); d3.select("#country-metrics-chart").style("display", "none"); return; }
            d3.select("#country-metrics-chart-container .chart-placeholder-text").style("display", "none"); const chartSvg = d3.select("#country-metrics-chart").style("display", "block"); chartSvg.selectAll("*").remove();
            const metricsData = [{ metric: 'gci', value: countryData.gci, label: metricCategories.gci.shortName, fullName: metricCategories.gci.displayName, color: "#1f77b4" },{ metric: 'ncsi', value: countryData.ncsi, label: metricCategories.ncsi.shortName, fullName: metricCategories.ncsi.displayName, color: "#ff7f0e" },{ metric: 'ddl', value: countryData.ddl, label: metricCategories.ddl.shortName, fullName: metricCategories.ddl.displayName, color: "#2ca02c" },{ metric: 'cei', value: countryData.cei, label: metricCategories.cei.shortName, fullName: metricCategories.cei.displayName, color: "#d62728" }].filter(d => d.value !== null && !isNaN(d.value));
            if (metricsData.length === 0) { d3.select("#country-metrics-chart-container .chart-placeholder-text").style("display", "block").text(`No metrics available for ${countryData.country}.`); chartSvg.style("display", "none"); return;}
            const containerNode = d3.select("#country-metrics-chart-container").node(); const svgWidth = containerNode.getBoundingClientRect().width; const svgHeight = 400; const margin = { top: 60, right: 30, bottom: 70, left: 60 }; const chartWidth = svgWidth - margin.left - margin.right; const chartHeight = svgHeight - margin.top - margin.bottom;
            chartSvg.attr("width", svgWidth).attr("height", svgHeight); const chartG = chartSvg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            chartSvg.append("text").attr("x", svgWidth / 2).attr("y", margin.top / 2).attr("text-anchor", "middle").attr("class", "metrics-chart-title").text(`Cybersecurity Metrics for ${countryData.country}`);
            const xScale = d3.scaleBand().domain(metricsData.map(d => d.label)).range([0, chartWidth]).padding(0.3);
            const maxValue = d3.max(metricsData, d => d.value); const yScale = d3.scaleLinear().domain([0, maxValue > 0 ? maxValue * 1.1 : 10]).range([chartHeight, 0]);
            chartG.selectAll(".bar").data(metricsData).join("rect").attr("class", "bar").attr("x", d => xScale(d.label)).attr("y", d => yScale(d.value)).attr("width", xScale.bandwidth()).attr("height", d => chartHeight - yScale(d.value)).attr("fill", d => d.color)
            .on("mouseover", function(event, d) { mapTooltip.style("opacity",1).html(`<strong>${d.fullName}</strong><br>Value: ${formatMapMetricValue(d.metric, d.value)}`).style("left",(event.pageX+10)+"px").style("top",(event.pageY-28)+"px");}).on("mouseout", function(){mapTooltip.style("opacity",0);});
            chartG.selectAll(".bar-value-label").data(metricsData).join("text").attr("class", "bar-value-label").attr("x", d => xScale(d.label) + xScale.bandwidth() / 2).attr("y", d => yScale(d.value) - 5).text(d => formatMapMetricValue(d.metric, d.value));
            chartG.append("g").attr("class", "x-axis").attr("transform", `translate(0,${chartHeight})`).call(d3.axisBottom(xScale)).selectAll("text").style("text-anchor", "middle");
            chartG.append("g").attr("class", "y-axis").call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format(".2~f")));
            chartSvg.append("text").attr("transform", "rotate(-90)").attr("y", margin.left / 4).attr("x", 0 - (chartHeight / 2) - margin.top).attr("dy", "1em").style("text-anchor", "middle").attr("class", "axis-label").text("Index Value");
        }
        // --- END OF COUNTRY METRICS BAR CHART CODE ---

        // --- GAUGE CHART AND INFO DISPLAY CODE ---
        function drawCountryGaugeChart(countryData) {
            const gaugeContainer = d3.select("#country-gauge-chart-container");
            const gaugeSvg = d3.select("#country-gauge-chart");
            
            gaugeContainer.select(".chart-placeholder-text").style("display", "none");
            gaugeSvg.style("display", "block").selectAll("*").remove();

            const ceiValue = countryData.cei;

            if (ceiValue === null || isNaN(ceiValue)) {
                gaugeContainer.select(".chart-placeholder-text")
                  .style("display", "block")
                  .text(`CEI is not available for ${countryData.country || 'selected country'}.`);
                gaugeSvg.style("display", "none");
                return;
            }
            
            const width = gaugeContainer.node().getBoundingClientRect().width;
            const height = 150; 
            const margin = { top: 10, right: 20, bottom: 40, left: 20 }; 
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            const radius = Math.min(chartWidth / 2, chartHeight);

            gaugeSvg.attr("width", width).attr("height", height);
            const g = gaugeSvg.append("g").attr("transform", `translate(${width / 2}, ${margin.top + radius})`);

            // Definicija gradijenta
            const defs = gaugeSvg.append("defs");
            const gradient = defs.append("linearGradient")
                .attr("id", "gaugeGradient")
                .attr("x1", "0%") // Gradijent ide s lijeva na desno
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%");

            // Boje za gradijent: zelena -> žuta -> crvena
            // Offseti određuju gdje se boja mijenja unutar gradijenta
            gradient.append("stop")
                .attr("offset", "0%") // Početak gradijenta
                .attr("stop-color", "#77dd77"); // Zelena (Sigurno)

            gradient.append("stop")
                .attr("offset", "50%") // Sredina gradijenta
                .attr("stop-color", "#fdfd96"); // Žuta (Upozorenje)

            gradient.append("stop")
                .attr("offset", "100%") // Kraj gradijenta
                .attr("stop-color", "#ff6961"); // Crvena (Ranjivo)


            const arcGenerator = d3.arc()
                .innerRadius(radius * 0.7)
                .outerRadius(radius)
                .startAngle(-Math.PI / 2) // -90 stupnjeva (lijevo)
                .endAngle(Math.PI / 2)   // +90 stupnjeva (desno)
                .cornerRadius(3);

            // Crtanje polukružnog luka s primijenjenim gradijentom
            g.append("path")
                .attr("d", arcGenerator)
                .style("fill", "url(#gaugeGradient)"); // Primijeni gradijent pomoću ID-a

            // Needle (kazaljka)
            const needleAngleScale = d3.scaleLinear()
                .domain([0, 1]) // CEI raspon (0 = sigurno, 1 = ranjivo)
                .range([-Math.PI / 2, Math.PI / 2]); // Raspon kuta za kazaljku

            const needleAngle = needleAngleScale(ceiValue);
            const needleLength = radius * 0.85;

            g.append("line")
                .attr("x1", 0).attr("y1", 0)
                .attr("x2", Math.cos(needleAngle - Math.PI / 2) * needleLength) 
                .attr("y2", Math.sin(needleAngle - Math.PI / 2) * needleLength)
                .attr("stroke", "black")
                .attr("stroke-width", 2.5)
                .attr("stroke-linecap", "round"); // Zaobljeni kraj kazaljke
            
            // Središnji krug za kazaljku
            g.append("circle").attr("cx", 0).attr("cy", 0).attr("r", 5).style("fill", "black");

            // Tekstualne oznake "SIGURNO" i "RANJIVO"
            g.append("text")
                .attr("class", "gauge-label")
                .attr("x", -radius * 0.8) // Pozicija lijevo
                .attr("y", radius * 0.35) 
                .text("Secure");

            g.append("text")
                .attr("class", "gauge-label")
                .attr("x", radius * 0.8) // Pozicija desno
                .attr("y", radius * 0.35) 
                .text("Vulnerable");

            // Prikaz CEI vrijednosti ispod brzinomjera
            gaugeSvg.append("text")
                .attr("class", "gauge-value-text")
                .attr("x", width / 2)
                .attr("y", height - margin.bottom / 2 + 5) 
                .text(`CEI: ${formatMapMetricValue('cei', ceiValue)}`);
        }

        function updateCountryInfoDisplay(countryData) {
            const infoContainer = d3.select("#country-info-display");
            infoContainer.selectAll("*").remove(); // Clear previous info
            infoContainer.select(".chart-placeholder-text").style("display", "none");


            if (!countryData || !countryData.country) {
                 infoContainer.append("p").attr("class","chart-placeholder-text").text("Select a country to view information.");
                return;
            }
            
            infoContainer.append("h3").text(countryData.country);
            infoContainer.append("p").text(`Continent: ${countryData.region || 'N/A'}`);
            
            // Determine status based on CEI
            let statusText = "Status: N/A";
            if (countryData.cei !== null && !isNaN(countryData.cei)) {
                if (countryData.cei < 0.35) {
                    statusText = "Status: Secure";
                } else if (countryData.cei < 0.67) {
                    statusText = "Status: Potentially Vulnerable";
                } else {
                    statusText = "Status: High Exposure / Vulnerable";
                }
            }
            infoContainer.append("p").text(statusText);
        }
        
        function initializeCountrySpecificDashboardPlaceholders() {
            // Placeholder for bar chart
            const barChartContainer = d3.select("#country-metrics-chart-container");
            barChartContainer.select(".chart-placeholder-text").style("display", "block");
            barChartContainer.select("#country-metrics-chart").style("display", "none");

            // Placeholder for gauge
            const gaugeContainer = d3.select("#country-gauge-chart-container");
            gaugeContainer.select("#country-gauge-chart").style("display", "none");
            
            // Placeholder for info
            const infoContainer = d3.select("#country-info-display");
            infoContainer.selectAll("h3, p:not(.chart-placeholder-text)").remove();
        }
        // --- END OF NEW GAUGE CHART AND INFO DISPLAY CODE ---

        //MOST SECURE AND MOST EXPOSED COUNTRIES
        function displayTopBottomCountries(allCountriesData) {
            const safestListUl = d3.select("#safest-countries-list ul");
            const exposedListUl = d3.select("#most-exposed-countries-list ul");

            safestListUl.html(""); // Očisti prethodne unose
            exposedListUl.html("");

            // Filtriraj zemlje koje imaju CEI vrijednost
            const countriesWithCEI = allCountriesData.filter(d => d.cei !== null && !isNaN(d.cei));

            if (countriesWithCEI.length === 0) {
                safestListUl.append("li").text("Nema dostupnih CEI podataka.");
                exposedListUl.append("li").text("Nema dostupnih CEI podataka.");
                return;
            }

            // Sortiraj po CEI (rastuće za najsigurnije)
            const sortedByCEIAsc = [...countriesWithCEI].sort((a, b) => a.cei - b.cei);
            
            // Sortiraj po CEI (padajuće za najizloženije, tj. rastuće pa obrnuto)
            // Ili direktno sortiraj padajuće: const sortedByCEIDesc = [...countriesWithCEI].sort((a, b) => b.cei - a.cei);
            
            const topSafest = sortedByCEIAsc.slice(0, 3);
            const topExposed = sortedByCEIAsc.slice(-3).reverse(); // Uzmi zadnje 3 i obrni redoslijed da najviši CEI bude prvi

            topSafest.forEach(country => {
                safestListUl.append("li")
                    .html(`${country.country} <span class="cei-value safest">${formatMapMetricValue('cei', country.cei)}</span>`);
            });
             if (topSafest.length === 0) safestListUl.append("li").text("Nema podataka.");


            topExposed.forEach(country => {
                exposedListUl.append("li")
                    .html(`${country.country} <span class="cei-value most-exposed">${formatMapMetricValue('cei', country.cei)}</span>`);
            });
            if (topExposed.length === 0) exposedListUl.append("li").text("Nema podataka.");
        }


        // --- DATA LOADING AND INITIALIZATION ---
        Promise.all([
            d3.json("https://unpkg.com/world-atlas@2/countries-110m.json"),
            d3.csv("Cyber_security.csv", d_csv => { 
                return { /* ... (same as before) ... */ 
                    country: d_csv.Country, region: d_csv.Region,
                    cei: d_csv.CEI && d_csv.CEI.trim() !== "" ? +d_csv.CEI : null,
                    gci: d_csv.GCI && d_csv.GCI.trim() !== "" ? +d_csv.GCI : null,
                    ncsi: d_csv.NCSI && d_csv.NCSI.trim() !== "" ? +d_csv.NCSI : null,
                    ddl: d_csv.DDL && d_csv.DDL.trim() !== "" ? +d_csv.DDL : null
                };
            })
        ]).then(([worldData, loadedCyberData]) => {
            cyberDataStore = loadedCyberData; 
            dataByCountryStore = new Map(cyberDataStore.map(d => [d.country, d]));

            const countries = topojson.feature(worldData, worldData.objects.countries);
            mapProjection.fitSize([mapWidth, mapHeight], countries);
            mapGroup.selectAll("path.country")
                .data(countries.features)
                .join("path")
                .attr("class", "country")
                .attr("d", mapPathGenerator)
                .style("vector-effect", "non-scaling-stroke")
                .on("mouseover", function(event, d_geo) { /* ... map tooltip ... */ mapTooltip.style("opacity", 1); d3.select(this).raise(); })
                .on("mousemove", function(event, d_geo) { /* ... map tooltip logic ... */ 
                    const gN=d_geo.properties.name,cN=nameMappings[gN]||gN,cD=dataByCountryStore.get(cN); let tT=`<strong>${gN}</strong>`;
                    if(cD){const mV=cD[currentMapMetric],cI=getMapCategoryInfo(currentMapMetric,mV); tT+=`<br><span class="tooltip-metric">${metricCategories[currentMapMetric].displayName}: ${formatMapMetricValue(currentMapMetric,mV)}</span>`; tT+=`<br><span class="tooltip-category">Category: ${cI.label}</span>`; tT+=`<br>Region: ${cD.region||'N/A'}`; for(const k in metricCategories) if(k!==currentMapMetric&&cD[k]!==null)tT+=`<br><small>${metricCategories[k].displayName}: ${formatMapMetricValue(k,cD[k])} (${getMapCategoryInfo(k,cD[k]).label})</small>`;}else tT+="<br>Data not available"; mapTooltip.html(tT).style("left",(event.pageX+15)+"px").style("top",(event.pageY-30)+"px");
                })
                .on("mouseout", function(event, d_geo) { mapTooltip.style("opacity", 0); })
                .on("click", function(event, d_geo) { 
                    const geoName = d_geo.properties.name;
                    const csvName = nameMappings[geoName] || geoName;
                    const countryDetails = dataByCountryStore.get(csvName);
                    
                    if (countryDetails) {
                        drawCountryMetricsChart(countryDetails);
                        drawCountryGaugeChart(countryDetails);
                        updateCountryInfoDisplay(countryDetails);
                    } else {
                        const placeholderData = { country: geoName, region: 'N/A', cei: null };
                        drawCountryMetricsChart(placeholderData); // Still show bar chart placeholder
                        drawCountryGaugeChart(placeholderData); // Show gauge placeholder
                        updateCountryInfoDisplay(placeholderData); // Show basic info placeholder
                        console.warn(`No detailed data for ${geoName} (CSV name: ${csvName})`);
                    }
                });
            
            updateMapAndLegend(currentMapMetric);
            initializeCountrySpecificDashboardPlaceholders(); // Initialize all placeholders

             displayTopBottomCountries(cyberDataStore);

            // Event Listeners for Map Controls
            d3.select("#metric-select").on("change", function(event) { updateMapAndLegend(d3.select(this).property("value")); });
            d3.select("#reset-zoom-button").on("click", () => { mapSvg.transition().duration(750).call(mapZoom.transform, d3.zoomIdentity); });

        }).catch(error => {
            console.error("Error loading data:", error);
            mapSvg.append("text").attr("x", 20).attr("y", 50).text("Error loading map or CSV. Check console.");
            d3.select("#dynamic-legend-header").html(`<p class="legend-title" style="color: red;">Error loading data.</p><p class="legend-description">Check console for details.</p>`);
            d3.select("#country-specific-dashboard").html(`<p class="chart-placeholder-text" style="color: red; width: 100%;">Error loading data for detailed view. See console.</p>`);
        });
    </script>
</body>
</html>